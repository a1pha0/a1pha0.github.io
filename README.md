# 数据结构

## 二叉搜索树（BST）

时间复杂度 O(lgn)
退化成链表时 O(n)

## 自平衡二叉搜索树（AVL）

AVL 自平衡二叉树的出现，其目的在于解决二叉搜索树退化成链表的问题。

左旋
右旋
左旋+右旋
右旋+左旋

## 2-3树

2–3树通过在一个节点存放1-2个元素来平衡树高。从而也使2-3树存在2叉节点和3叉节点。
2-3树是3阶B树，2-3-4树是4阶B树。

如果进行一次调衡后，上一层父节点达到3个元素，则需要2次调衡，来满足2-3树的规则。

## 红黑树（Red Black Tree）

红黑树（Red Black Tree）是一种自平衡二叉查找树。

建立在 BST 二叉搜索树的基础上，AVL、2-3树、红黑树都是自平衡二叉树（统称B-树）。

现在再来看下红黑树的五条定义：

- **每个节点不是红色就是黑色。**
    黑色决定平衡，红色不决定平衡。这对应了2-3树中一个节点内可以存放1~2个节点。
- **根是黑色的。**
    这条规则有时会被省略。由于根总是可以从红色变为黑色，但不一定相反，因此该规则对分析几乎没有影响。
- **所有叶子 (NIL) 都是黑色的。**
    这里指的是红黑树都会有一个空的叶子节点，是红黑树自己的规则。
- **如果一个节点是红色的，那么它的两个子节点都是黑色的。**
    通常这条规则也叫不会有连续的红色节点。这体现在2-3树中，一个节点最多临时会有3个节点，中间是黑色节点，左右是红色节点。2-3树中出现这样的情况后，会进行节点迁移，中间节点成为父节点，左右节点成为子节点。
- **从给定节点到其任何后代 NIL 节点的每条路径都包含相同数量的黑色节点。**
    对应2-3树中，每一层都只是有一个节点贡献了树高决定平衡性，也就是对应红黑树中的黑色节点。

### 插入
插入的节点默认为红色
case 1. 什么都不用做 (父节点为黑色)
case 2. 染色 (父节点和叔叔节点都为红色)
case 3. 染色+右旋 (父节点为红色而叔叔节点为黑色)
case 4. 染色+左旋 (父节点为红色而叔叔节点为黑色)
case 5. 左旋+染色+右旋 (左旋 + case 2) (父节点为红色而叔叔节点为黑色)
case 6. 右旋+染色+左旋 (右旋 + case 3) (父节点为红色而叔叔节点为黑色)

### 删除
删除节点的后继节点的右子节点为N，N的parent为P，P的右子节点为S，S的左子节点SL，右子节点SR

1. 删除节点为RED：什么都不做
2. 删除节点为BLACK，N为RED：将N变为BLACK
3. 删除节点和N都是BLACK
    case 1. N是根节点：什么都不做
    case 2. P、S、SL、SR颜色依次为BRBB：P变为红色, S变为黑色    -->case 456
    case 3. P、S、SL、SR颜色依次为BBBB：P变为红色，递归调整P    -->case 123456
    case 4. P、S、SL、SR颜色依次为RBBB：P变为黑色，S变为红色    -->Done
    case 5. SL、SR一黑一红, 红色的记为Y，N与Y的左右相同：Y变为黑色，S变为红色。若Y为S的左子节点，将S右旋；若Y为S的右子节点，将S左旋。 --> case 6
    case 6. SL、SR一黑一红, 红色的记为Y，N与Y的左右不同：S的颜色变为P的颜色，P变为黑色。若N为P的左子节点，将P右旋，SR变为黑色；若N为P的右子节点，将P左旋，SL变为黑色。  -->Done


---


# 算法


---

# 虚幻引擎

## 